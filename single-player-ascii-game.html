<!DOCTYPE html>
<html>
<head>
    <title>Single-Player Party-Based ASCII Roguelike</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }
        
        #game-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 100vh;
            height: 100vh;
            gap: 0;
        }
        
        #left-panel, #right-panel {
            background: #000;
            border: 1px solid #0f0;
            padding: 10px;
            overflow-y: auto;
            font-size: 11px;
        }
        
        #left-panel {
            border-right: 2px solid #0f0;
        }
        
        #right-panel {
            border-left: 2px solid #0f0;
        }
        
        #map-container {
            background: #000;
            border-top: 1px solid #0f0;
            border-bottom: 1px solid #0f0;
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100vh;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        
        #center-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .ui-state {
            display: none;
            flex: 1;
            padding: 10px;
            overflow: auto;
        }
        
        .ui-state.active {
            display: flex;
            flex-direction: column;
        }

        /* Status displays */
        .status-section {
            border: 1px solid #333;
            margin: 5px 0;
            padding: 5px;
        }

        .status-title {
            color: #0f0;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .status-bar {
            width: 100%;
            height: 12px;
            border: 1px solid #333;
            background: #111;
            margin: 2px 0;
        }

        .status-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.3s;
        }

        /* Party member displays */
        .party-section {
            border: 1px solid #333;
            margin: 5px 0;
            padding: 5px;
            max-height: 200px;
            overflow-y: auto;
        }

        .party-member {
            border: 1px solid #222;
            margin: 2px 0;
            padding: 3px;
            background: #001100;
        }

        .party-member.active {
            border-color: #0f0;
            background: #002200;
        }

        .party-member.dead {
            color: #666;
            background: #110000;
        }

        /* Abilities Grid */
        .abilities-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 5px 0;
        }

        .ability-slot {
            padding: 3px 5px;
            border: 1px solid #333;
            background: #001100;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            text-align: center;
        }
        
        .ability-slot:hover {
            border-color: #0f0;
            background: #002200;
        }
        
        .ability-slot.available {
            border-color: #0f0;
            background: #001100;
        }
        
        .ability-slot.unavailable {
            border-color: #555;
            background: #000;
            color: #555;
            cursor: not-allowed;
        }
        
        .ability-slot.selected {
            border-color: #ff0;
            background: #220;
            color: #ff0;
        }
        
        .ability-name {
            font-weight: bold;
        }
        
        .ability-ap {
            font-size: 9px;
            color: #aaa;
        }

        /* Map display */
        #map-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1;
            white-space: pre;
            color: #0f0;
            padding: 10px;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Map Legend */
        .legend-section {
            border: 1px solid #333;
            margin: 5px 0;
            padding: 5px;
            max-height: 200px;
            overflow-y: auto;
        }

        .legend-category {
            margin-bottom: 8px;
        }

        .legend-category-title {
            color: #0f0;
            font-weight: bold;
            font-size: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 3px;
            padding-bottom: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 1px 0;
            font-size: 10px;
            line-height: 1.2;
        }

        .legend-symbol {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            width: 15px;
            text-align: center;
            margin-right: 8px;
            color: #0f0;
        }

        .legend-description {
            flex: 1;
            color: #ccc;
        }

        /* Adventure log */
        #adventure-log {
            height: 300px;
            overflow-y: auto;
            background: #000;
            border: 1px solid #333;
            padding: 5px;
            font-size: 10px;
        }

        .log-entry {
            margin: 1px 0;
            padding: 1px;
        }

        .log-entry.system {
            color: #888;
        }

        .log-entry.combat {
            color: #f80;
        }

        .log-entry.skill {
            color: #08f;
        }

        /* Controls */
        .controls {
            border: 1px solid #333;
            padding: 5px;
            margin: 5px 0;
        }

        .control-button {
            background: #002200;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 6px;
            margin: 1px;
            cursor: pointer;
            font-size: 10px;
            font-family: inherit;
        }

        .control-button:hover {
            background: #003300;
        }

        .control-button:disabled {
            background: #111;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }

        /* Guild interface */

        /* Character Creation Interface */
        .character-creation {
            display: none;
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            background: #000;
            border: 2px solid #0f0;
            padding: 20px;
            z-index: 1001;
            overflow-y: auto;
        }

        .character-creation.active {
            display: block;
        }

        .world-location {
            cursor: pointer;
            padding: 2px;
        }

        .world-location:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .world-location.selected {
            background: rgba(0, 255, 0, 0.3);
        }
        
        .world-map-display {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: 100%;
        }
        
        .world-map-grid {
            border: 1px solid #00ff00;
            background: #000;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            line-height: 1.2;
        }

        .creation-section {
            border: 1px solid #333;
            margin: 10px 0;
            padding: 10px;
        }

        .creation-title {
            color: #0f0;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 14px;
        }

        .skill-allocation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .skill-category {
            border: 1px solid #222;
            padding: 8px;
            background: #001100;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 3px 0;
            font-size: 11px;
        }

        .skill-points {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .point-button {
            background: #002200;
            border: 1px solid #0f0;
            color: #0f0;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }

        .point-button:hover {
            background: #003300;
        }

        .point-button:disabled {
            background: #111;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }

        .weapon-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .weapon-option {
            border: 1px solid #333;
            padding: 10px;
            background: #001100;
            cursor: pointer;
            transition: all 0.2s;
        }

        .weapon-option:hover {
            background: #002200;
            border-color: #0f0;
        }

        .weapon-option.selected {
            background: #003300;
            border-color: #0f0;
            border-width: 2px;
        }

        .weapon-name {
            color: #0f0;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .weapon-stats {
            font-size: 10px;
            color: #888;
        }

        .creation-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .stat-display {
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Left Panel: Party Status & Abilities -->
        <div id="left-panel">
            <!-- Game Status -->
            <div class="status-section">
                <div class="status-title">Game Status</div>
                <div>Location: <span id="location-display">Guild Base</span></div>
                <div>Floor: <span id="current-floor">-</span> Room: <span id="current-room">-</span></div>
                <div>Gold: <span id="party-gold">0</span></div>
            </div>

            <!-- Active Party Member -->
            <div class="status-section">
                <div class="status-title">Active Character</div>
                <div id="active-character-name">None Selected</div>
                <div>Health: <span id="active-health">0/0</span></div>
                <div class="status-bar">
                    <div class="status-fill" id="health-fill" style="width: 100%;"></div>
                </div>
                <div>Level: <span id="active-level">0</span></div>
                <div>Mastery: <span id="active-mastery">Novice</span></div>
            </div>

            <!-- Party Members -->
            <div class="party-section">
                <div class="status-title">Party (0/6)</div>
                <div id="party-members"></div>
            </div>

            <!-- Abilities -->
            <div class="status-section">
                <div class="status-title">Abilities</div>
                <div class="abilities-grid" id="abilities-grid">
                    <!-- Will be populated with ability slots 1-9 -->
                </div>
            </div>

            <!-- Map Legend -->
            <div class="legend-section">
                <div class="status-title">Map Legend</div>
                <div id="map-legend">
                    <!-- Will be populated dynamically based on visible symbols -->
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="control-button" onclick="toggleGuildInterface()">Guild Base</button>
                <button class="control-button" onclick="startNewRun()" id="start-run-btn">Start Run</button>
                <button class="control-button" onclick="endCurrentRun()" id="end-run-btn" disabled>End Run</button>
                <button class="control-button" onclick="testCombat()" id="test-combat-btn">Test Combat</button>
            </div>
        </div>

        <!-- Center Panel: Game Map -->
        <div id="map-container">
            <div id="center-content">
                <!-- Dungeon/Map View -->
                <div id="dungeon-state" class="ui-state">
                    <div id="map-display">
                        Welcome to the Single-Player Party-Based ASCII Roguelike!
                        
                        Use the Guild Base to create and manage your party.
                        Start a run when you have party members.
                        
                        Controls:
                        - WASD / Arrow Keys: Move
                        - 1-9: Use Abilities
                        - Space: Wait/Pass Turn
                        - G: Guild Base, M: World Map
                    </div>
                </div>
                
                <!-- World Map View -->
                <div id="world-map-state" class="ui-state">
                    <h2>World Map - Explore Dungeons</h2>
                    <div class="world-map-display">
                        <div>
                            <h3>Available Locations</h3>
                            <div id="world-map-grid" class="world-map-grid">
                                <!-- ASCII world map will be rendered here -->
                            </div>
                        </div>
                        <div>
                            <h3>Location Info</h3>
                            <div id="location-info" style="height: 200px; border: 1px solid #333; padding: 10px; overflow-y: auto;">
                                <div class="info-text">Select a location to view details...</div>
                            </div>
                            <div style="margin-top: 20px;">
                                <button class="control-button" onclick="enterSelectedDungeon()">Enter Dungeon</button>
                                <button class="control-button" onclick="switchToGuildState()">Return to Guild</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Guild View -->
                <div id="guild-state" class="ui-state active">
                    <h2>Guild Base</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: calc(100% - 60px);">
                        <div>
                            <h3>Create New Character</h3>
                            <div style="display: flex; gap: 5px;">
                                <button class="control-button" onclick="window.gameManager.createRandomCharacter()">Quick Random</button>
                                <button class="control-button" onclick="createNewCharacter()">Custom Creation</button>
                            </div>
                            <p style="font-size: 10px; color: #888; margin-top: 5px;">Quick Random creates a character instantly. Custom Creation opens the full character builder.</p>
                            
                            <h3>Available Characters</h3>
                            <div id="available-characters" style="height: 150px; overflow-y: auto; border: 1px solid #333; padding: 5px;">
                                <!-- Will show stored characters -->
                            </div>
                        </div>
                        <div>
                            <h3>Current Party</h3>
                            <div id="guild-party-display" style="height: 200px; overflow-y: auto; border: 1px solid #333; padding: 5px;">
                                <!-- Will show current party -->
                            </div>
                            <div style="display: flex; gap: 10px; margin-top: 10px;">
                                <button class="control-button" onclick="switchToWorldMapState()">Explore World</button>
                                <button class="control-button" onclick="switchToDungeonState()">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Character Creation View -->
                <div id="character-creation-state" class="ui-state">
                    <div class="creation-title">Character Creation</div>
                    
                    <!-- Basic Info -->
                    <div class="creation-section">
                        <div class="creation-title">Basic Information</div>
                        <div style="margin-bottom: 10px;">
                            <label for="character-name-input">Character Name:</label><br>
                            <input type="text" id="character-name-input" style="background: #111; color: #0f0; border: 1px solid #333; padding: 5px; width: 300px;" placeholder="Enter character name">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <button class="control-button" onclick="generateRandomCharacterData()" style="margin-right: 10px;">Generate Random</button>
                            <span style="font-size: 10px; color: #888;">Click to auto-fill with random skills and weapon</span>
                        </div>
                    </div>

                    <!-- Skill Point Allocation -->
                    <div class="creation-section">
                        <div class="creation-title">Skill Allocation (Points Available: <span id="available-skill-points">25</span>)</div>
                        <div class="skill-allocation" id="skill-allocation-grid">
                            <!-- Will be populated with skill categories -->
                        </div>
                    </div>

                    <!-- Starting Weapon Selection -->
                    <div class="creation-section">
                        <div class="creation-title">Choose Starting Weapon</div>
                        <div class="weapon-selection" id="weapon-selection-grid">
                            <!-- Will be populated with weapon options -->
                        </div>
                    </div>

                    <!-- Character Preview -->
                    <div class="creation-section">
                        <div class="creation-title">Character Preview</div>
                        <div class="creation-stats">
                            <div>
                                <div class="stat-display">
                                    <strong>Name:</strong> <span id="preview-name">Unnamed</span><br>
                                    <strong>Health:</strong> <span id="preview-health">100/100</span><br>
                                    <strong>Starting Weapon:</strong> <span id="preview-weapon">None Selected</span><br>
                                </div>
                            </div>
                            <div>
                                <div class="stat-display">
                                    <strong>Top Skills:</strong><br>
                                    <div id="preview-skills">None allocated</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="control-button" onclick="createCharacterFromBuilder()" id="create-character-btn" disabled>Create Character</button>
                        <button class="control-button" onclick="resetCharacterBuilder()">Reset</button>
                        <button class="control-button" onclick="switchToGuildState()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Adventure Log & Info -->
        <div id="right-panel">
            <!-- Adventure Log -->
            <div class="status-section">
                <div class="status-title">Adventure Log</div>
                <div id="adventure-log">
                    <div class="log-entry system">Game initialized. Welcome to your adventure!</div>
                    <div class="log-entry system">Visit the Guild Base to create party members.</div>
                </div>
            </div>

            <!-- Current Action -->
            <div class="status-section">
                <div class="status-title">Current Action</div>
                <div id="current-action">Idle</div>
                <div id="action-description">Select an action to see details.</div>
            </div>

            <!-- Quick Stats -->
            <div class="status-section">
                <div class="status-title">Quick Stats</div>
                <div>Runs Completed: <span id="runs-completed">0</span></div>
                <div>Deepest Floor: <span id="deepest-floor">0</span></div>
                <div>Characters Lost: <span id="characters-lost">0</span></div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <div style="font-size: 9px;">
                    <strong>Keyboard Controls:</strong><br>
                    WASD/Arrows: Move<br>
                    1-9: Use Abilities<br>
                    Space: Wait Turn<br>
                    G: Guild Base<br>
                    M: World Map (from Guild)<br>
                    ESC: Close Menus<br>
                </div>
            </div>
        </div>
    </div>



    <!-- Load our new systems -->
    <script src="src/character/skills/SkillCategories.js"></script>
    <script src="src/core/EventSystem.js"></script>
    <script src="src/core/GameState.js"></script>
    <script src="src/character/skills/SkillSystem.js"></script>
    
    <!-- Core abilities system - MUST be loaded in order -->
    <script src="src/abilities/core/AbilityRegistry.js"></script>
    <script src="src/abilities/core/AbilitySlotManager.js"></script>
    <script src="src/abilities/core/AbilityEngine.js"></script>
    
    <!-- Ability definition files -->
    <script src="src/abilities/combat/MeleeAbilities.js"></script>
    <script src="src/abilities/combat/RangedAbilities.js"></script>
    <script src="src/abilities/combat/DefensiveAbilities.js"></script>
    <script src="src/abilities/combat/PhysicalDamageAbilities.js"></script>
    <script src="src/abilities/magic/MagicAbilities.js"></script>
    <script src="src/abilities/magic/ElementalAbilities.js"></script>
    <script src="src/abilities/exploration/ExplorationAbilities.js"></script>
    <script src="src/abilities/passive/PassiveAbilities.js"></script>
    <script src="src/abilities/hybrid/HybridAbilities.js"></script>
    
    <script src="src/character/generator/CharacterGenerator.js"></script>
    <script src="src/equipment/Weapons.js"></script>
    <script src="src/enemies/EnemySystem.js"></script>
    <script src="src/combat/CombatManager.js"></script>
    <script src="src/combat/TurnManager.js"></script>
    <script src="src/dungeon/DungeonGenerator.js"></script>
    
    <!-- Input System -->
    <script src="src/input/core/InputManager.js"></script>
    <script src="src/input/handlers/AbilityHandler.js"></script>
    
    <!-- UI System -->
    <script src="src/ui/core/UIManager.js"></script>
    <script src="src/ui/panels/LeftPanel.js"></script>
    
    <!-- Movement System -->
    <script src="src/movement/core/MovementSystem.js"></script>
    <script src="src/movement/validation/MovementValidator.js"></script>
    <script src="src/movement/ai/EnemyAI.js"></script>
    
    <!-- Encounters System -->
    <script src="src/encounters/core/EncounterManager.js"></script>
    <script src="src/encounters/scaling/EncounterScaling.js"></script>
    <script src="src/encounters/combat/TacticalCombat.js"></script>
    
    <!-- Game Management System -->
    <script src="src/game/core/GameManager.js"></script>

    <script>
        // Initialize game systems
        const eventSystem = new EventSystem();
        const gameState = new GameState();
        const skillSystem = new SkillSystem(eventSystem);
        
        // Initialize new abilities system
        const abilityRegistry = new AbilityRegistry();
        const abilitySlotManager = new AbilitySlotManager(eventSystem);
        const abilityEngine = new AbilityEngine(
            eventSystem, 
            skillSystem, 
            abilityRegistry, 
            abilitySlotManager, 
            gameState
        );
        
        const weaponSystem = new WeaponSystem();
        const enemySystem = new EnemySystem();
        const characterGenerator = new CharacterGenerator(eventSystem, skillSystem, weaponSystem);
        const turnManager = new TurnManager(gameState, eventSystem);
        const combatManager = new CombatManager(gameState, eventSystem, skillSystem, turnManager);
        const dungeonGenerator = new DungeonGenerator(eventSystem, enemySystem);
        
        let activeCharacterIndex = 0;
        let selectedAbility = null;

        // Map Legend System
        class MapSymbolTracker {
            constructor() {
                this.visibleSymbols = new Set();
                this.symbolData = new Map();
            }

            // Scan a text/map content for symbols
            scanMapContent(mapContent) {
                this.visibleSymbols.clear();
                this.symbolData.clear();

                const lines = mapContent.split('\n');
                for (const line of lines) {
                    for (const char of line) {
                        if (char && char !== ' ' && char !== '\t') {
                            this.visibleSymbols.add(char);
                        }
                    }
                }
            }

            // Get all currently visible symbols
            getVisibleSymbols() {
                return Array.from(this.visibleSymbols);
            }

            // Add symbol with metadata
            addSymbolData(symbol, category, description, color = '#0f0') {
                this.symbolData.set(symbol, { category, description, color });
            }

            // Get symbol metadata
            getSymbolData(symbol) {
                return this.symbolData.get(symbol);
            }
        }

        class LegendRenderer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.symbolDefinitions = this.initializeSymbolDefinitions();
            }

            // Define what each symbol means
            initializeSymbolDefinitions() {
                return {
                    // Player & Characters
                    '@': { category: 'Player', description: 'Your Character', color: '#ff0' },
                    
                    // Terrain
                    '#': { category: 'Terrain', description: 'Wall', color: '#0f0' },
                    '.': { category: 'Terrain', description: 'Floor', color: '#0f0' },
                    '^': { category: 'Terrain', description: 'Mountain', color: '#888' },
                    '~': { category: 'Terrain', description: 'Water', color: '#08f' },
                    
                    // Locations
                    'G': { category: 'Locations', description: 'Guild Base', color: '#ff0' },
                    '?': { category: 'Locations', description: 'Unknown Location', color: '#888' },
                    'R': { category: 'Locations', description: 'Ancient Ruins', color: '#f80' },
                    'F': { category: 'Locations', description: 'Dark Forest', color: '#080' },
                    'C': { category: 'Locations', description: 'Crystal Caves', color: '#08f' },
                    'T': { category: 'Locations', description: 'Shadow Tower', color: '#808' },
                    
                    // Items (common RPG symbols)
                    '$': { category: 'Items', description: 'Gold', color: '#ff0' },
                    '!': { category: 'Items', description: 'Potion', color: '#f0f' },
                    '%': { category: 'Items', description: 'Food', color: '#fa0' },
                    '*': { category: 'Items', description: 'Treasure', color: '#ff0' },
                    '/': { category: 'Items', description: 'Weapon', color: '#888' },
                    '[': { category: 'Items', description: 'Armor', color: '#888' },
                    '=': { category: 'Items', description: 'Ring', color: '#f80' },
                    
                    // Doors & Containers
                    '+': { category: 'Objects', description: 'Door', color: '#a50' },
                    '&': { category: 'Objects', description: 'Chest', color: '#a50' },
                    '{': { category: 'Objects', description: 'Container', color: '#888' },
                    
                    // Common enemy letters (will be enhanced later)
                    'g': { category: 'Enemies', description: 'Goblin', color: '#f00' },
                    'r': { category: 'Enemies', description: 'Rat', color: '#f00' },
                    's': { category: 'Enemies', description: 'Skeleton', color: '#f00' },
                    'o': { category: 'Enemies', description: 'Orc', color: '#f00' },
                    'w': { category: 'Enemies', description: 'Wolf', color: '#f00' },
                    'b': { category: 'Enemies', description: 'Bandit', color: '#f00' },
                    'D': { category: 'Enemies', description: 'Dragon', color: '#f00' }
                };
            }

            // Render the legend based on visible symbols
            render(visibleSymbols) {
                if (!this.container) return;

                // Group symbols by category
                const categories = {};
                const unknown = [];

                visibleSymbols.forEach(symbol => {
                    const definition = this.symbolDefinitions[symbol];
                    if (definition) {
                        if (!categories[definition.category]) {
                            categories[definition.category] = [];
                        }
                        categories[definition.category].push({ symbol, ...definition });
                    } else {
                        // Track unknown symbols
                        unknown.push(symbol);
                    }
                });

                // Build HTML
                let html = '';
                
                // Define category order for consistent display
                const categoryOrder = ['Player', 'Terrain', 'Locations', 'Enemies', 'Items', 'Objects'];
                
                categoryOrder.forEach(categoryName => {
                    if (categories[categoryName] && categories[categoryName].length > 0) {
                        html += `<div class="legend-category">`;
                        html += `<div class="legend-category-title">${categoryName}</div>`;
                        
                        categories[categoryName].forEach(item => {
                            html += `<div class="legend-item">`;
                            html += `<span class="legend-symbol" style="color: ${item.color}">${item.symbol}</span>`;
                            html += `<span class="legend-description">${item.description}</span>`;
                            html += `</div>`;
                        });
                        
                        html += `</div>`;
                    }
                });

                // Add unknown symbols if any
                if (unknown.length > 0) {
                    html += `<div class="legend-category">`;
                    html += `<div class="legend-category-title">Unknown</div>`;
                    unknown.forEach(symbol => {
                        html += `<div class="legend-item">`;
                        html += `<span class="legend-symbol">${symbol}</span>`;
                        html += `<span class="legend-description">Unknown Symbol</span>`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                }

                this.container.innerHTML = html || '<div style="color: #888; font-size: 10px;">No symbols to display</div>';
            }
        }

        // Initialize legend system
        const mapSymbolTracker = new MapSymbolTracker();
        const legendRenderer = new LegendRenderer('map-legend');
        

        // Initialize game
        function initializeGame() {
            setupEventListeners();
            // Initialize systems
            window.inputManager.initialize();
            window.uiManager.initialize();
            window.leftPanel.initialize();
            window.movementSystem.initialize();
            window.movementValidator.initialize();
            window.enemyAI.initialize();
            window.encounterManager.initialize();
            window.encounterScaling.initialize();
            window.tacticalCombat.initialize();
            window.gameManager.initialize();
            
            // Set initial UI state
            window.inputManager.setUIState(currentUIState);
            window.uiManager.currentUIState = currentUIState;
            
            // Update displays
            window.uiManager.updateAllDisplays();
            window.uiManager.updateGuildInterface();
            window.uiManager.clearMapLegend();
            
            addLog('Single-player party-based roguelike initialized!', 'system');
            addLog('Welcome to the Guild Base! Create your party to begin.', 'system');
        }

        // Event listeners for game systems
        function setupEventListeners() {
            eventSystem.on('CHARACTER_SKILL_GAINED', (data) => {
                addLog(`${data.characterId} improved in a skill! Level ${data.oldLevel} → ${data.newLevel}`, 'skill');
                updateAllDisplays();
            });

            eventSystem.on('PARTY_MEMBER_ADDED', (data) => {
                addLog(`${data.characterId} joined the party!`, 'system');
                updateAllDisplays();
            });

            // Combat events with consolidated logging
            const combatEvents = {
                'COMBAT_STARTED': (d) => `Combat begins! ${d.partyMembers?.length || 0} party members vs ${d.enemies?.length || 0} enemies`,
                'COMBAT_ENDED': (d) => `Combat ended: ${d.victory ? 'Victory!' : 'Defeat'}`,
                'TURN_STARTED': (d) => `${d.character?.name || d.enemy?.name || d.entityId}'s turn begins (${d.ap || 0} AP)`,
                'DAMAGE_DEALT': (d) => `${d.attackerId} deals ${d.damage} damage to ${d.targetId}`,
                'CHARACTER_DIED': (d) => `${d.characterId} has been defeated!`,
                'PARTY_WIPE': (d) => `PARTY WIPED! ${d.charactersLost} characters lost to permadeath.`
            };
            
            Object.entries(combatEvents).forEach(([event, messageFunc]) => {
                eventSystem.on(event, (data) => {
                    addLog(messageFunc(data), event === 'TURN_STARTED' ? 'turn' : 'combat');
                    updateAllDisplays();
                });
            });
            
            eventSystem.on('COMBAT_MESSAGE', (data) => addLog(data.message, 'combat'));
        }




        // Enemy AI and Movement System





























        // Guild interface
        // Legacy functions - now redirect to new state system
        function toggleGuildInterface() {
            if (currentUIState === 'guild') {
                switchToDungeonState();
            } else {
                switchToGuildState();
            }
        }

        function closeGuildInterface() {
            switchToDungeonState();
        }

        // World Map System
        const dungeonLocations = [
            {
                id: 'ancient_ruins',
                name: 'Ancient Ruins',
                symbol: 'R',
                x: 5, y: 3,
                difficulty: 'Easy',
                floors: 3,
                description: 'Crumbling stone ruins filled with weak undead and basic treasures. Perfect for new adventurers.',
                unlocked: true
            },
            {
                id: 'dark_forest',
                name: 'Dark Forest Depths', 
                symbol: 'F',
                x: 12, y: 6,
                difficulty: 'Medium',
                floors: 4,
                description: 'A twisted woodland where corrupted beasts and nature spirits guard ancient secrets.',
                unlocked: true
            },
            {
                id: 'crystal_caves',
                name: 'Crystal Caves',
                symbol: 'C',
                x: 20, y: 4,
                difficulty: 'Hard',
                floors: 5,
                description: 'Deep caverns lined with magical crystals. Dangerous elementals protect valuable gems.',
                unlocked: false
            },
            {
                id: 'shadow_tower',
                name: 'Shadow Tower',
                symbol: 'T',
                x: 15, y: 12,
                difficulty: 'Nightmare',
                floors: 6,
                description: 'A dark spire that pierces the sky. Only the strongest parties dare enter its cursed halls.',
                unlocked: false
            }
        ];

        let selectedLocation = null;

        // Legacy function - now redirects to new state system
        function openWorldMap() {
            switchToWorldMapState();
        }

        function renderWorldMap() {
            const mapGrid = document.getElementById('world-map-grid');
            const mapWidth = 60;  // Much larger for center panel
            const mapHeight = 30; // Much larger for center panel
            
            // Create ASCII world map
            let mapData = [];
            for (let y = 0; y < mapHeight; y++) {
                mapData[y] = new Array(mapWidth).fill('.');
            }
            
            // Add terrain features
            for (let x = 0; x < mapWidth; x++) {
                for (let y = 0; y < mapHeight; y++) {
                    if (Math.random() < 0.1) {
                        mapData[y][x] = (Math.random() < 0.5) ? '^' : '~';
                    }
                }
            }
            
            // Place guild base (centered in larger map)
            mapData[15][5] = 'G';
            
            // Update dungeon locations for larger map
            const scaledLocations = [
                { ...dungeonLocations[0], x: 10, y: 6 },  // Ancient Ruins
                { ...dungeonLocations[1], x: 25, y: 12 }, // Dark Forest
                { ...dungeonLocations[2], x: 45, y: 8 },  // Crystal Caves
                { ...dungeonLocations[3], x: 35, y: 20 }  // Shadow Tower
            ];
            
            // Place dungeon locations
            scaledLocations.forEach((location, index) => {
                if (location.y < mapHeight && location.x < mapWidth) {
                    mapData[location.y][location.x] = dungeonLocations[index].unlocked ? location.symbol : '?';
                    // Update original locations for click handling
                    dungeonLocations[index].x = location.x;
                    dungeonLocations[index].y = location.y;
                }
            });
            
            // Render map
            let html = '<div style="line-height: 1.2;">';
            for (let y = 0; y < mapHeight; y++) {
                let row = '';
                for (let x = 0; x < mapWidth; x++) {
                    const char = mapData[y][x];
                    const location = dungeonLocations.find(loc => loc.x === x && loc.y === y && loc.unlocked);
                    
                    if (location) {
                        row += `<span class="world-location" data-location="${location.id}" onclick="selectLocation('${location.id}')">${char}</span>`;
                    } else if (char === 'G') {
                        row += `<span style="color: #ffff00;">${char}</span>`;
                    } else {
                        row += char;
                    }
                }
                html += row + '<br>';
            }
            html += '</div>';
            html += '<div style="margin-top: 10px; font-size: 10px;">';
            html += 'G=Guild Base, R=Ruins, F=Forest, C=Caves, T=Tower, ?=Locked Location';
            html += '</div>';
            
            mapGrid.innerHTML = html;
            
            // Update legend for world map
            updateWorldMapLegend(mapData);
        }

        function selectLocation(locationId) {
            selectedLocation = locationId;
            const location = dungeonLocations.find(loc => loc.id === locationId);
            
            // Remove previous selection
            document.querySelectorAll('.world-location').forEach(el => el.classList.remove('selected'));
            // Add selection to clicked location
            document.querySelector(`[data-location="${locationId}"]`).classList.add('selected');
            
            // Show location info
            const infoDiv = document.getElementById('location-info');
            infoDiv.innerHTML = `
                <h4>${location.name}</h4>
                <p><strong>Difficulty:</strong> ${location.difficulty}</p>
                <p><strong>Floors:</strong> ${location.floors}</p>
                <p><strong>Description:</strong> ${location.description}</p>
                <p><strong>Status:</strong> ${location.unlocked ? 'Available' : 'Locked'}</p>
            `;
        }

        function enterSelectedDungeon() {
            if (!selectedLocation) {
                addLog('Please select a location first.', 'system');
                return;
            }
            
            const location = dungeonLocations.find(loc => loc.id === selectedLocation);
            if (!location.unlocked) {
                addLog('This location is locked. Complete other dungeons to unlock it.', 'system');
                return;
            }
            
            // Switch to dungeon state
            switchToDungeonState();
            
            // Start dungeon run with selected location
            const runResult = gameState.startNewRun();
            if (runResult.success) {
                gameState.currentRun.locationTheme = selectedLocation;
                gameState.currentRun.maxFloor = location.floors;
                addLog(`Entering ${location.name}... Prepare for adventure!`, 'system');
                updateMapDisplay();
            } else {
                addLog(`Failed to start run: ${runResult.reason}`, 'system');
            }
        }

        function returnToGuild() {
            switchToDungeonState();
            gameState.returnToGuild();
            updateMapDisplay();
            addLog('Returned to Guild Base.', 'system');
        }

        function createNewCharacter() {
            // Switch to character creation state and initialize
            switchToCharacterCreationState();
            // Initialize the character generator
            characterGenerator.openCharacterCreation();
        }
        
        
        
        function createFullRandomCharacter() {
            const name = document.getElementById('char-name-input').value.trim();
            if (!name) {
                addLog('Please enter a character name first!', 'system');
                return;
            }
            
            // Generate and preview random character
            const randomCharacter = generateRandomCharacter(name);
            
            // Show preview
            updateCharacterPreview(randomCharacter);
            
            // Store temporarily for finalization
            window.tempCharacter = randomCharacter;
        }
        
        function updateCharacterPreview(character) {
            const preview = document.getElementById('character-preview');
            if (!character) {
                preview.innerHTML = '<p>Enter a name and choose creation method to preview your character.</p>';
                return;
            }
            
            let html = `<h4>${character.name}</h4>`;
            html += `<p><strong>Health:</strong> ${character.maxHealth}</p>`;
            html += `<p><strong>AP:</strong> ${character.maxAP}</p>`;
            html += `<p><strong>Weapon:</strong> ${character.equipment.weapon ? character.equipment.weapon.name : 'None'}</p>`;
            
            html += '<h5>Skills:</h5>';
            const skills = Object.entries(character.skills)
                .filter(([key, skill]) => skill.level > 0)
                .sort((a, b) => b[1].level - a[1].level);
                
            if (skills.length > 0) {
                skills.forEach(([skillKey, skill]) => {
                    const skillDef = skillSystem.skillDefinitions[skillKey];
                    const name = skillDef ? skillDef.name : skillKey;
                    html += `<div>${name}: ${skill.level} (${skill.mastery})</div>`;
                });
            } else {
                html += '<div>No skills allocated</div>';
            }
            
            preview.innerHTML = html;
        }
        
        function finalizeCharacterCreation() {
            if (!window.tempCharacter) {
                addLog('No character to create! Generate a character first.', 'system');
                return;
            }
            
            const character = window.tempCharacter;
            
            // Add to guild storage
            gameState.guild.storedCharacters.set(character.id, character);
            
            // Initialize abilities
            initializeCharacterAbilities(character);
            
            // Clean up
            window.tempCharacter = null;
            
            // Return to guild
            switchToGuildState();
            updateGuildInterface();
            
            addLog(`Created character: ${character.name}`, 'system');
        }
        
        function generateRandomCharacterData() {
            if (!characterGenerator || !characterGenerator.characterBuilder) {
                addLog('Character generator not ready. Please try again.', 'system');
                return;
            }
            
            // Preserve the current name
            const currentName = document.getElementById('character-name-input').value;
            
            // Reset only the skill allocation and weapon selection, not the name
            characterGenerator.characterBuilder.allocatedSkills = {};
            characterGenerator.characterBuilder.availablePoints = 25;
            characterGenerator.characterBuilder.selectedWeapon = null;
            
            // Update the available points display
            const pointsDisplay = document.getElementById('available-skill-points');
            if (pointsDisplay) pointsDisplay.textContent = '25';
            
            // Clear all skill displays
            const allSkills = [];
            Object.keys(SKILL_CATEGORIES).forEach(categoryKey => {
                const category = SKILL_CATEGORIES[categoryKey];
                Object.keys(category.skills).forEach(skillKey => {
                    allSkills.push(skillKey);
                    const skillDisplay = document.getElementById(`skill-${skillKey}`);
                    if (skillDisplay) skillDisplay.textContent = '0';
                });
            });
            
            // Allocate all 25 points randomly
            let pointsToAllocate = 25;
            let attempts = 0;
            const maxAttempts = 1000; // Prevent infinite loop
            
            while (pointsToAllocate > 0 && attempts < maxAttempts) {
                attempts++;
                const randomSkill = allSkills[Math.floor(Math.random() * allSkills.length)];
                const currentPoints = characterGenerator.characterBuilder.allocatedSkills[randomSkill] || 0;
                
                // Only add points if we haven't maxed this skill (max 10 per skill)
                if (currentPoints < 10) {
                    characterGenerator.adjustSkillPoints(randomSkill, 1);
                    pointsToAllocate--;
                }
            }
            
            // Restore the name
            document.getElementById('character-name-input').value = currentName;
            
            // Select a random starting weapon
            const weapons = characterGenerator.weaponSystem.getStartingWeapons();
            if (weapons && weapons.length > 0) {
                const randomWeapon = weapons[Math.floor(Math.random() * weapons.length)];
                characterGenerator.selectWeapon(randomWeapon.id);
            }
            
            addLog('Generated random character data with all 25 skill points allocated!', 'system');
        }

        // Character Creation Functions
        const openCharacterCreation = () => characterGenerator.openCharacterCreation();
        const closeCharacterCreation = () => characterGenerator.closeCharacterCreation();
        const resetCharacterBuilder = () => characterGenerator.resetCharacterBuilder();

        // Initialize character abilities with default slots
        function initializeCharacterAbilities(character) {
            abilitySlotManager.initializeSlots(character);
            const basicAbilities = ['basic_attack', 'move', 'wait', 'defend'];
            basicAbilities.forEach((ability, index) => {
                abilitySlotManager.slotActiveAbility(character, ability, index);
            });
            
            const availableAbilities = abilityEngine.getAvailableAbilities(character);
            const skillAbility = availableAbilities.find(a => a.skillRequirements.length > 0);
            if (skillAbility && availableAbilities.length > 4) {
                abilitySlotManager.slotActiveAbility(character, skillAbility.key, 4);
                addLog(`${character.name} learned ${skillAbility.name}!`, 'system');
            }
            return availableAbilities;
        }

        function createCharacterFromBuilder() {
            const character = characterGenerator.createCharacterFromBuilder(gameState);
            if (character) {
                const availableAbilities = initializeCharacterAbilities(character);
                gameState.guild.storedCharacters.set(character.id, character);
                
                if (gameState.party.members.size < 6) {
                    const result = gameState.addPartyMember(character);
                    if (result.success) {
                        eventSystem.emit('PARTY_MEMBER_ADDED', { characterId: character.id });
                    }
                }

                // Return to guild state
                switchToGuildState();
                updateGuildInterface();
                addLog(`Created character: ${character.name}`, 'system');
                addLog(`Abilities ready: ${availableAbilities.length} total available`, 'system');
            }
        }

        document.addEventListener('input', (e) => {
            if (e.target.id === 'character-name-input') characterGenerator.handleNameInput();
        });

        // Utility functions
        function getActiveCharacter() {
            const partyMembers = Array.from(gameState.party.members.values());
            return partyMembers[activeCharacterIndex] || null;
        }

        function startNewRun() {
            const result = gameState.startNewRun();
            if (result.success) {
                addLog(`Started dungeon run - Floor ${result.floor}!`, 'system');
                document.getElementById('start-run-btn').disabled = true;
                document.getElementById('end-run-btn').disabled = false;
                updateAllDisplays();
                updateMapDisplay();
            } else {
                addLog(result.reason, 'system');
            }
        }

        function endCurrentRun() {
            if (gameState.currentRun.active) {
                // Clear enemies from current run
                const enemies = gameState.getCurrentEnemies();
                enemies.clear();
                
                gameState.returnToGuild();
                addLog('Returned to Guild Base', 'system');
                document.getElementById('start-run-btn').disabled = false;
                document.getElementById('end-run-btn').disabled = true;
                updateAllDisplays();
            }
        }

        // Test combat functionality
        function testCombat() {
            if (gameState.party.members.size === 0) {
                alert('You need party members to test combat! Visit the Guild Base first.');
                return;
            }

            if (gameState.combat.active) {
                // End current combat
                combatManager.forceEndCombat();
                addLog('Combat test ended', 'system');
            } else {
                // Start test combat
                const result = combatManager.forceStartCombat();
                if (result.success) {
                    addLog('Test combat started!', 'system');
                } else {
                    alert(`Failed to start combat: ${result.reason}`);
                }
            }
        }

        const updateAllDisplays = () => {
            updateGameStatus();
            updatePartyDisplay();
            updateActiveCharacterDisplay();
            updateAbilitiesDisplay();
            updateQuickStats();
        };

        const updateGameStatus = () => {
            const elements = {
                'location-display': gameState.location.type,
                'current-floor': gameState.currentRun.active ? gameState.currentRun.floor : '-',
                'current-room': gameState.currentRun.active ? '1' : '-',
                'party-gold': gameState.party.gold
            };
            Object.entries(elements).forEach(([id, value]) => {
                document.getElementById(id).textContent = value;
            });
        };

        // Utility function to create character display elements
        function createCharacterDisplay(character, className, onClick, extraInfo = '') {
            const div = document.createElement('div');
            div.className = className;
            if (onClick) div.onclick = onClick;
            
            const mastery = skillSystem.getMasteryLevel(character);
            div.innerHTML = `
                <div>${character.name} (${mastery})</div>
                <div>HP: ${character.health}/${character.maxHealth}</div>
                <div>Level: ${character.level}${extraInfo}</div>
            `;
            return div;
        }

        function updatePartyDisplay() {
            const partyContainer = document.getElementById('party-members');
            const partyMembers = Array.from(gameState.party.members.values());
            
            partyContainer.innerHTML = '';
            partyMembers.forEach((character, index) => {
                const memberDiv = createCharacterDisplay(
                    character,
                    `party-member ${index === activeCharacterIndex ? 'active' : ''}`,
                    () => { activeCharacterIndex = index; updateAllDisplays(); }
                );
                partyContainer.appendChild(memberDiv);
            });

            document.querySelector('.party-section .status-title').textContent = `Party (${partyMembers.length}/6)`;
            
            // Update location display
            const locationDisplay = document.getElementById('location-display');
            if (gameState.location.type === 'guild') {
                locationDisplay.textContent = 'Guild Base';
            } else if (gameState.location.type === 'overworld') {
                const theme = gameState.currentRun.locationTheme;
                locationDisplay.textContent = theme ? theme.name : 'Dungeon Floor ' + gameState.currentRun.floor;
            } else if (gameState.location.type === 'combat') {
                locationDisplay.textContent = 'Combat!';
            }
        }

        function updateActiveCharacterDisplay() {
            const activeCharacter = getActiveCharacter();
            if (!activeCharacter) {
                document.getElementById('active-character-name').textContent = 'None Selected';
                document.getElementById('active-health').textContent = '0/0';
                document.getElementById('active-level').textContent = '0';
                document.getElementById('active-mastery').textContent = 'Novice';
                document.getElementById('health-fill').style.width = '0%';
                return;
            }

            document.getElementById('active-character-name').textContent = activeCharacter.name;
            document.getElementById('active-health').textContent = `${activeCharacter.health}/${activeCharacter.maxHealth}`;
            document.getElementById('active-level').textContent = activeCharacter.level;
            document.getElementById('active-mastery').textContent = skillSystem.getMasteryLevel(activeCharacter);
            
            const healthPercent = (activeCharacter.health / activeCharacter.maxHealth) * 100;
            document.getElementById('health-fill').style.width = `${healthPercent}%`;
        }

        // Utility function to create ability slot HTML
        function createAbilitySlotHTML(slotNum, name, apText, available = false) {
            return `<div class="ability-name">[${slotNum}] ${name}</div><div class="ability-ap">${apText}</div>`;
        }

        function updateAbilitiesDisplay() {
            const abilitiesGrid = document.getElementById('abilities-grid');
            const activeCharacter = getActiveCharacter();
            const slots = activeCharacter ? abilitySlotManager.initializeSlots(activeCharacter) : null;
            
            abilitiesGrid.innerHTML = '';

            for (let i = 1; i <= 9; i++) {
                const slot = document.createElement('div');
                const slotIndex = i - 1;
                
                if (!activeCharacter) {
                    slot.className = 'ability-slot unavailable';
                    slot.innerHTML = createAbilitySlotHTML(i, 'Empty', 'No Character');
                } else {
                    const abilityKey = slots.active[slotIndex];
                    
                    if (abilityKey) {
                        const ability = abilityRegistry.getAbility(abilityKey);
                        const canUse = abilityEngine.canUseAbility(activeCharacter, abilityKey);
                        const apCost = abilityRegistry.calculateAPCost(activeCharacter, ability);
                        const successRate = abilityRegistry.calculateSuccessRate(activeCharacter, abilityKey);
                        
                        slot.className = `ability-slot ${canUse.canUse ? 'available' : 'unavailable'}`;
                        slot.innerHTML = createAbilitySlotHTML(i, ability.name, `${apCost}AP (${successRate}%)`);
                        slot.onclick = canUse.canUse ? () => handleAbilityKey(i) : null;
                        if (!canUse.canUse) slot.title = canUse.reason;
                    } else {
                        slot.className = 'ability-slot unavailable';
                        slot.innerHTML = createAbilitySlotHTML(i, 'Empty', 'No Ability');
                        slot.onclick = () => openAbilitySlotting(activeCharacter, slotIndex);
                    }
                }
                
                abilitiesGrid.appendChild(slot);
            }
        }
        
        function openAbilitySlotting(character, slotIndex) {
            const availableAbilities = abilityEngine.getAvailableAbilities(character);
            if (!availableAbilities.length) {
                addLog(`${character.name} has no abilities available to slot`, 'system');
                return;
            }
            
            const result = abilitySlotManager.slotActiveAbility(character, availableAbilities[0].key, slotIndex);
            const message = result.success 
                ? `Slotted ${availableAbilities[0].name} in slot ${slotIndex + 1}`
                : `Failed to slot ability: ${result.reason}`;
            
            addLog(message, 'system');
            if (result.success) updateAllDisplays();
        }

        function updateMapDisplay() {
            let mapContent = '';
            
            // Check if we're in an active dungeon run
            if (gameState.currentRun.active) {
                mapContent = renderDungeonRoom();
            } else {
                // Default exploration view when not in dungeon
                const { playerX: x, playerY: y } = gameState.location;
                mapContent = `Position: (${x}, ${y})\n\n`;
                
                for (let row = y - 10; row <= y + 10; row++) {
                    let line = '';
                    for (let col = x - 20; col <= x + 20; col++) {
                        line += (col === x && row === y) ? '@' : 
                                (Math.abs(col - x) + Math.abs(row - y) < 5) ? '.' : '#';
                    }
                    mapContent += line + '\n';
                }
            }
            
            document.getElementById('map-display').textContent = mapContent;
            
            // Update map legend
            updateMapLegend(mapContent);
        }

        function renderDungeonRoom() {
            // Check if we're in combat mode
            if (gameState.combat.active) {
                return renderCombatRoom();
            }
            
            // Get current room from dungeon generator
            const currentRoom = gameState.currentRun.floor || 1;
            const template = dungeonGenerator.getCurrentTemplate(currentRoom);
            
            if (!template) {
                return 'Error: Could not load room template\n';
            }

            // Generate enemies for this room if not already done
            try {
                ensureRoomEnemiesGenerated();
                console.log('Enemy generation attempt completed');
            } catch (error) {
                console.warn('Could not generate enemies:', error);
            }

            // Create map display
            let mapContent = `Floor ${gameState.currentRun.floor} - Room ${currentRoom}\n\n`;
            
            // Build the room layout
            const width = template.width;
            const height = template.height;
            
            // Initialize room with floors
            const roomMap = [];
            for (let y = 0; y < height; y++) {
                roomMap[y] = new Array(width).fill('.');
            }
            
            // Place walls
            if (template.walls) {
                template.walls.forEach(([x, y]) => {
                    if (y >= 0 && y < height && x >= 0 && x < width) {
                        roomMap[y][x] = '#';
                    }
                });
            }
            
            // Place objects (chests, doors, etc.) - SECOND layer
            if (template.objects) {
                template.objects.forEach(obj => {
                    if (obj.x >= 0 && obj.x < width && obj.y >= 0 && obj.y < height) {
                        let symbol = '&'; // default chest symbol
                        switch (obj.type) {
                            case 'chest': symbol = '&'; break;
                            case 'door': symbol = '+'; break;
                            case 'container': symbol = '{'; break;
                            default: symbol = '?'; break;
                        }
                        // Only place if not a wall
                        if (roomMap[obj.y][obj.x] !== '#') {
                            roomMap[obj.y][obj.x] = symbol;
                        }
                    }
                });
            }
            
            // Place enemies - THIRD layer (above objects, below player)
            const enemies = gameState.getCurrentEnemies ? gameState.getCurrentEnemies() : new Map();
            console.log(`Found ${enemies.size} enemies for room:`, enemies);
            enemies.forEach((enemy, id) => {
                console.log(`Placing enemy ${enemy.name} at (${enemy.x}, ${enemy.y})`);
                if (enemy.alive && enemy.x >= 0 && enemy.x < width && enemy.y >= 0 && enemy.y < height) {
                    // Only place enemy if it's not a wall
                    if (roomMap[enemy.y][enemy.x] !== '#') {
                        // Use first letter of enemy name as symbol
                        const enemySymbol = enemy.name ? enemy.name.charAt(0).toLowerCase() : 'e';
                        roomMap[enemy.y][enemy.x] = enemySymbol;
                        console.log(`Placed enemy symbol '${enemySymbol}' at (${enemy.x}, ${enemy.y})`);
                    } else {
                        console.log(`Enemy ${enemy.name} position blocked by wall`);
                    }
                } else {
                    console.log(`Enemy ${enemy.name} has invalid position or is dead`);
                }
            });
            
            // Place player character LAST (top layer - always visible)
            let playerX = gameState.location.playerX;
            let playerY = gameState.location.playerY;
            
            // If player position is not set or invalid, find a suitable starting position
            if (playerX == null || playerY == null || 
                playerX < 0 || playerX >= width || playerY < 0 || playerY >= height ||
                roomMap[playerY] && roomMap[playerY][playerX] === '#') {
                
                // Find first open floor space (avoid walls)
                let found = false;
                for (let y = 1; y < height - 1 && !found; y++) {
                    for (let x = 1; x < width - 1 && !found; x++) {
                        if (roomMap[y][x] === '.') {
                            playerX = x;
                            playerY = y;
                            // Update game state with new position
                            gameState.location.playerX = x;
                            gameState.location.playerY = y;
                            found = true;
                        }
                    }
                }
            }
            
            if (playerY >= 0 && playerY < height && playerX >= 0 && playerX < width) {
                // Player overwrites anything else on their tile
                roomMap[playerY][playerX] = '@';
            }
            
            // Convert to string
            for (let y = 0; y < height; y++) {
                mapContent += roomMap[y].join('') + '\n';
            }
            
            return mapContent;
        }

        function renderCombatRoom() {
            const combatRoom = gameState.combat.currentRoom;
            if (!combatRoom) {
                return 'Error: No combat room data\n';
            }

            let mapContent = `TACTICAL COMBAT - Round ${gameState.combat.round}\n\n`;
            
            // Build the combat room layout
            const width = combatRoom.width;
            const height = combatRoom.height;
            
            // Initialize room with floors
            const roomMap = [];
            for (let y = 0; y < height; y++) {
                roomMap[y] = new Array(width).fill('.');
            }
            
            // Place walls
            if (combatRoom.walls) {
                combatRoom.walls.forEach(([x, y]) => {
                    if (y >= 0 && y < height && x >= 0 && x < width) {
                        roomMap[y][x] = '#';
                    }
                });
            }
            
            // Place combat enemies
            const enemies = gameState.combat.enemies;
            enemies.forEach((enemy, id) => {
                if (enemy.alive && enemy.x >= 0 && enemy.x < width && enemy.y >= 0 && enemy.y < height) {
                    const enemySymbol = enemy.name ? enemy.name.charAt(0).toUpperCase() : 'E';
                    roomMap[enemy.y][enemy.x] = enemySymbol;
                }
            });
            
            // Place party members
            const partyMembers = Array.from(gameState.party.members.values());
            partyMembers.forEach((member, index) => {
                if (member.health > 0 && member.x >= 0 && member.x < width && member.y >= 0 && member.y < height) {
                    // Use numbers for party members in combat
                    const memberSymbol = (index + 1).toString();
                    roomMap[member.y][member.x] = memberSymbol;
                }
            });
            
            // Highlight current turn character
            const currentTurn = gameState.combat.turnOrder[gameState.combat.currentTurnIndex];
            if (currentTurn && currentTurn.x >= 0 && currentTurn.x < width && currentTurn.y >= 0 && currentTurn.y < height) {
                // Current turn character gets highlighted with @
                roomMap[currentTurn.y][currentTurn.x] = '@';
            }
            
            // Convert to string
            for (let y = 0; y < height; y++) {
                mapContent += roomMap[y].join('') + '\n';
            }
            
            // Add combat status
            mapContent += `\nCurrent Turn: ${currentTurn ? currentTurn.name : 'Unknown'}\n`;
            mapContent += `Enemies Remaining: ${Array.from(enemies.values()).filter(e => e.alive).length}\n`;
            
            return mapContent;
        }

        function updateMapLegend(mapContent) {
            // Only update legend in dungeon state
            if (currentUIState === 'dungeon') {
                mapSymbolTracker.scanMapContent(mapContent);
                const visibleSymbols = mapSymbolTracker.getVisibleSymbols();
                legendRenderer.render(visibleSymbols);
            }
        }

        function updateWorldMapLegend(mapData) {
            // Only update legend in world map state
            if (currentUIState === 'world-map') {
                // Convert mapData array to string format for scanning
                let mapContent = '';
                mapData.forEach(row => {
                    mapContent += row.join('') + '\n';
                });
                
                mapSymbolTracker.scanMapContent(mapContent);
                const visibleSymbols = mapSymbolTracker.getVisibleSymbols();
                legendRenderer.render(visibleSymbols);
            }
        }

        function updateGuildInterface() {
            updateAvailableCharacters();
            updateGuildPartyDisplay();
        }

        function updateAvailableCharacters() {
            const container = document.getElementById('available-characters');
            container.innerHTML = '';
            
            gameState.guild.storedCharacters.forEach((character, id) => {
                const div = document.createElement('div');
                div.style.cssText = 'border: 1px solid #333; padding: 3px; margin: 2px; cursor: pointer;';
                div.innerHTML = `<div>${character.name} (Level ${character.level})</div><div style="font-size: 9px;">${skillSystem.getMasteryLevel(character)}</div>`;
                div.onclick = () => addToParty(id);
                container.appendChild(div);
            });
        }

        function updateGuildPartyDisplay() {
            const container = document.getElementById('guild-party-display');
            container.innerHTML = '';
            
            Array.from(gameState.party.members.values()).forEach((character) => {
                const div = document.createElement('div');
                div.style.cssText = 'border: 1px solid #0f0; padding: 3px; margin: 2px; background: #001100;';
                div.innerHTML = `<div>${character.name}</div><div style="font-size: 9px;">HP: ${character.health}/${character.maxHealth}</div>`;
                container.appendChild(div);
            });
        }

        function addToParty(characterId) {
            const character = gameState.guild.storedCharacters.get(characterId);
            if (!character) return;
            
            if (!character.abilitySlots) {
                initializeCharacterAbilities(character);
            }
            
            const result = gameState.addPartyMember(character);
            if (result.success) {
                eventSystem.emit('PARTY_MEMBER_ADDED', { characterId: character.id });
                updateGuildInterface();
            } else {
                alert(result.reason);
            }
        }

        const updateQuickStats = () => {
            const stats = gameState.playerProgress;
            const elements = {
                'runs-completed': stats.runsCompleted,
                'deepest-floor': stats.deepestFloor,
                'characters-lost': stats.totalCharactersLost
            };
            Object.entries(elements).forEach(([id, value]) => {
                document.getElementById(id).textContent = value;
            });
        };

        function addLog(message, type = 'system') {
            const log = document.getElementById('adventure-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // UI State Management System
        let currentUIState = 'guild';  // Start at guild base instead of dungeon
        
        function switchUIState(newState) {
            // Hide current state
            document.querySelectorAll('.ui-state').forEach(el => el.classList.remove('active'));
            
            // Show new state
            const newStateEl = document.getElementById(newState + '-state');
            if (newStateEl) {
                newStateEl.classList.add('active');
                currentUIState = newState;
                
                // Update input manager state
                if (window.inputManager) {
                    window.inputManager.setUIState(newState);
                }
                
                // Update specific state content and legends
                if (newState === 'world-map') {
                    renderWorldMap();
                } else if (newState === 'guild') {
                    updateGuildInterface();
                    // Clear legend in guild state
                    document.getElementById('map-legend').innerHTML = '<div style="color: #888; font-size: 10px;">No map active</div>';
                } else if (newState === 'character-creation') {
                    // Character creation state is now in the center panel
                    // The CharacterGenerator will handle the interface setup
                    // Clear legend in character creation state
                    document.getElementById('map-legend').innerHTML = '<div style="color: #888; font-size: 10px;">No map active</div>';
                } else if (newState === 'dungeon') {
                    // Update map and legend for dungeon state
                    updateMapDisplay();
                }
                
                addLog(`Switched to ${newState} view`, 'system');
            }
        }
        
        function switchToDungeonState() {
            switchUIState('dungeon');
            updateMapDisplay();
        }
        
        function switchToGuildState() {
            switchUIState('guild');
        }
        
        function switchToWorldMapState() {
            if (gameState.party.members.size === 0) {
                addLog('You need at least one party member to explore the world!', 'system');
                return;
            }
            switchUIState('world-map');
        }
        
        function switchToCharacterCreationState() {
            switchUIState('character-creation');
        }
        
        function initializeCharacterCreationInterface() {
            const content = document.getElementById('character-creation-content');
            content.innerHTML = `
                <h2>Character Creation</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: calc(100% - 60px);">
                    <div>
                        <h3>Basic Information</h3>
                        <label>Character Name:</label>
                        <input type="text" id="char-name-input" placeholder="Enter character name" style="width: 100%; margin: 10px 0;">
                        
                        <h3>Quick Options</h3>
                        <button class="control-button" onclick="createFullRandomCharacter()" style="width: 100%; margin: 5px 0;">Generate Random Character</button>
                        <button class="control-button" onclick="showCustomCreation()" style="width: 100%; margin: 5px 0;">Custom Character</button>
                        
                        <div id="custom-creation" style="display: none;">
                            <h4>Skill Allocation (25 points)</h4>
                            <div id="skill-allocation" style="height: 200px; overflow-y: auto; border: 1px solid #333; padding: 5px;">
                                <!-- Skill allocation will go here -->
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3>Character Preview</h3>
                        <div id="character-preview" style="height: 300px; border: 1px solid #333; padding: 10px; overflow-y: auto;">
                            <p>Enter a name and choose creation method to preview your character.</p>
                        </div>
                        <div style="margin-top: 20px;">
                            <button class="control-button" onclick="finalizeCharacterCreation()">Create Character</button>
                            <button class="control-button" onclick="switchToGuildState()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>